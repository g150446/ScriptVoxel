# アーキテクチャ仕様

## システムアーキテクチャ概要

### アーキテクチャ原則

#### 1. C++モジュール統合パターン

ScriptVoxelは **GDScript-over-C++** アーキテクチャに従います:

- **C++レイヤー (godot_voxelモジュール):** パフォーマンス重視の操作を処理
  - ボクセルデータの保存と圧縮
  - メッシュ生成(マーチングキューブ、transvoxel)
  - LOD管理
  - 衝突検出
  - ストリーミングとチャンク管理

- **GDScriptレイヤー (このプロジェクト):** ゲームロジックを実装
  - 地形生成アルゴリズム
  - ゲームプレイメカニクス
  - ユーザーインタラクション
  - ネットワーキングロジック
  - UIシステム

#### 2. デモ中心の組織化

各デモはアーキテクチャ的に独立しています:
- 自己完結型のシーンファイル
- デモ間の依存関係を最小限に
- `common/`ディレクトリの共有ユーティリティ
- 特定のボクセルモジュール機能を実証

#### 3. シングルトンレジストリパターン

共有データのグローバルレジストリ:
- **Blocks** - ブロックタイプレジストリ(最初に初期化する必要あり)
- **Items** - アイテムデータベース
- **DDD** - デバッグドローシステム(オートロード)

### コアC++クラス (godot_voxelモジュール)

#### 地形ノード

| クラス | 目的 | LODサポート | ユースケース |
|-------|------|------------|-------------|
| `VoxelTerrain` | 固定LOD地形 | なし | ブロックゲーム、一貫した詳細度 |
| `VoxelLodTerrain` | 可変LOD地形 | あり | スムーズ地形、大規模ワールド |

#### 生成システム

```
VoxelGenerator (基底クラス)
├── VoxelGeneratorScript (GDScript拡張可能)
├── VoxelGeneratorNoise2D
├── VoxelGeneratorNoise3D
└── VoxelGeneratorMultipassCB (コールバックベース)
```

**主要クラス:**
- **VoxelGeneratorScript:** カスタムGDScriptジェネレーターの基底
- **VoxelGeneratorMultipassCB:** マルチパス生成を可能にする(構造物配置)
- **VoxelBuffer:** 読み書き操作用のボクセルデータコンテナ

#### 編集ツール

- **VoxelTool:** ボクセル操作の基底クラス
- **VoxelToolTerrain:** 地形固有の編集操作
- **操作:** `do_sphere()`, `do_box()`, `paste()`, `paste_masked()`

#### 物理統合

- **VoxelBoxMover:** ボクセル衝突対応のキャラクターコントローラー
  - AABB-ボクセル衝突を処理
  - ボクセルワールド用にGodotのCharacterBody3Dを置き換え
  - 衝突解決付きの移動を提供

#### マルチプレイヤーシステム

- **VoxelTerrainMultiplayerSynchronizer:** サーバー権限地形同期
- **VoxelViewer:** 地形ロードが必要な位置をマーク
  - 各プレイヤーにアタッチされてストリーミング用

#### ブロックシステム

- **VoxelBlockyLibrary:** ブロックモデルと衝突を定義
  - ボクセルIDをビジュアルモデルにマッピング
  - 衝突形状を構成
  - 回転バリアントをサポート

#### パスファインディング

- **VoxelAStarGrid3D:** ボクセルグリッド上のA*パスファインディング
  - ボクセル対応ナビゲーション
  - 設定可能なトラバーサルルール

### ブロックゲームアーキテクチャ

最も複雑なデモで、完全なゲームシステムとして構造化されています:

```
BlockyGame (ルートノード)
├── Blocks (レジストリ - 最初の子である必要あり)
│   └── ブロック定義とマッピング
├── VoxelTerrain (C++地形ノード)
│   ├── VoxelBlockyLibrary (モデル/衝突)
│   └── Generator (VoxelGeneratorScriptを拡張)
│       └── TreeGenerator (構造物の事前生成)
├── Items (アイテムデータベースシングルトン)
├── RandomTicks (草の広がりシミュレーション)
├── Water (キューベースの水シミュレーション)
├── Players (コンテナ)
│   └── CharacterAvatarインスタンス
│       ├── CharacterController (VoxelBoxMover)
│       ├── AvatarInteraction (ボクセルレイキャスト)
│       ├── Inventory
│       └── Camera (MouseLook)
├── GUI
│   ├── Hotbar
│   ├── InventoryWindow
│   └── Crosshair
└── Environment
```

#### 重要な初期化順序

1. **Blocksレジストリ** - 最初の子である必要があり、他のシステムが依存
2. **VoxelTerrain** - ジェネレーターとライブラリで初期化
3. **Items** - アイテムデータベース
4. **シミュレーションシステム** - RandomTicks、Water
5. **Players** - 地形の準備後にスポーン

### 地形生成アーキテクチャ

#### シングルパス生成フロー

```
VoxelGeneratorScript._generate_block()
    ↓
1. チャンク原点からワールド位置を計算
    ↓
2. ノイズを使用してハイトマップを生成
    ↓
3. レイヤーごとにボクセルバッファを埋める
    │
    ├─→ 高さ以下: 土/石
    ├─→ 高さ: 草/砂
    └─→ 高さ以上: 空気/水
    ↓
4. 構造物を配置(木、植物)
    ↓
5. メッシング用にC++に戻る
```

#### マルチパス生成フロー

```
パス0 (地形):
VoxelGeneratorMultipassCB._generate_block(pass_index=0)
    ↓
基本地形を生成(ハイトマップ、ブロック)
    ↓
C++モジュールに戻る
    ↓
パス1 (構造物):
VoxelGeneratorMultipassCB._generate_block(pass_index=1)
    ↓
パス0から地形を読み取り可能
    ↓
地形に基づいて構造物を配置
    ↓
C++モジュールに戻る
```

**利点:** パス1はパス0から実際の地形を読み取れるため、以下が可能:
- 草ブロック上にのみ木を配置
- 地形に適合する構造物
- 複雑なマルチブロック機能

### マルチプレイヤーアーキテクチャ

#### ネットワークトポロジー

```
サーバー (HOSTモード)
├── 権限のある地形状態
├── 同期機能付きVoxelTerrain
├── シミュレーションシステム(水、ランダムティック)
└── リモートプレイヤーVoxelViewers

クライアント (CLIENTモード)
├── 同期された地形(読み取り専用)
├── ローカルプレイヤー(権限のある物理)
└── リモートプレイヤーアバター(位置同期)
```

#### 権限モデル

| システム | 権限 | 同期方法 |
|---------|------|---------|
| 地形/ボクセル | サーバー | VoxelTerrainMultiplayerSynchronizer |
| ローカルプレイヤー物理 | クライアント | ローカルシミュレーション |
| プレイヤー位置 | クライアント | RPCブロードキャスト |
| ブロック編集 | サーバー | RPCリクエスト/レスポンス |
| シミュレーション | サーバー | 地形同期経由で自動 |

#### ネットワークフロー: ブロック配置

```
クライアントアクション:
プレイヤーがブロック配置をクリック
    ↓
クライアント: ローカルで配置を検証
    ↓
クライアント → サーバーRPC: receive_place_single_block(pos, block_id)
    ↓
サーバー: 検証して地形を変更
    ↓
サーバー → 全クライアント: VoxelTerrainMultiplayerSynchronizer経由で自動同期
    ↓
全クライアント: 更新されたボクセルデータを受信
```

### ボクセルシミュレーションアーキテクチャ

#### ランダムティックシステム

```
RandomTicksノード
    ↓
毎フレーム:
    ↓
1. プレイヤー周囲100ブロック半径を計算
    ↓
2. 512個のランダムボクセル位置を選択
    ↓
3. 各位置について:
    VoxelTool.run_blocky_random_tick(callback)
        ↓
    コールバックがボクセル情報を受信
        ↓
    シミュレーションルールを適用(例: 草の広がり)
```

**草の広がりアルゴリズム:**
1. ボクセルが土かチェック
2. 上のボクセルが空気か(光があるか)チェック
3. 条件を満たす場合: 土を草に変換

#### 水シミュレーションシステム

```
Waterノード
├── キューA(現在のフレーム)
├── キューB(次のフレーム)
└── タイマー(0.2秒間隔)

シミュレーションループ:
    ↓
キューAから64ボクセルを処理
    ↓
各水ボクセルについて:
    ├─→ 4つの水平隣接をチェック
    ├─→ 1つの下隣接をチェック
    ├─→ 隣接が空気の場合: 水に変換、キューBに追加
    └─→ 続行
    ↓
64回更新後:
    キューA ↔ キューBをスワップ
    ↓
繰り返し
```

### プレイヤーシステムアーキテクチャ

#### キャラクターコントローラー

```
CharacterAvatar
├── CharacterController (character_controller.gd)
│   ├── VoxelBoxMover (C++衝突)
│   ├── 入力処理
│   ├── 移動物理
│   └── ジャンプ/重力
├── AvatarInteraction (avatar_interaction.gd)
│   ├── ボクセルレイキャスト
│   ├── ブロック配置/削除
│   ├── ブロックピック
│   └── ツール/アイテム使用
├── Inventory (inventory.gd)
│   ├── 27バッグスロット
│   ├── 9ホットバースロット
│   └── ドラッグアンドドロップシステム
└── Camera
    └── MouseLook (一人称コントロール)
```

#### ボクセルインタラクションフロー

```
プレイヤー入力(クリック)
    ↓
AvatarInteraction: ボクセルワールドにレイキャスト
    ↓
ヒット検出:
    ├─→ プライマリアクション(ブロック削除)
    ├─→ セカンダリアクション(ブロック配置)
    └─→ 中クリック(ブロックピック)
    ↓
VoxelTool経由で位置のブロックを取得
    ↓
必要に応じて回転を適用
    ↓
VoxelTool経由で地形を更新
    ↓
マルチプレイヤー: サーバーにRPCを送信
```

### デバッグシステム

#### デバッグドローアーキテクチャ (DDD)

```
DebugDraw (オートロード as "DDD")
├── HUDテキストシステム
│   ├── キーバリューペア
│   └── 自動更新表示
├── 3D描画システム
│   ├── ボックス
│   ├── ライン
│   ├── レイ
│   ├── メッシュ
│   └── 残留フレーム管理
└── パフォーマンス統計
```

**使用パターン:**
```gdscript
DDD.set_text("FPS", Engine.get_frames_per_second())
DDD.draw_box(position, size, Color.RED)
```

### リソース管理

#### ブロックライブラリ (.tresファイル)

```
VoxelBlockyLibrary
├── ブロック定義
│   ├── ボクセルID割り当て
│   ├── メッシュモデル
│   ├── 衝突形状
│   └── マテリアル参照
└── VoxelTerrainによってロード
```

#### マテリアルシステム

- **ブロックマテリアル:** ブロックテクスチャ用のテクスチャ配列
- **スムーズマテリアル:** スムーズ地形用のトリプラナーマッピング
- **.tresリソースファイルで構成**

### データフロー概要

```
ユーザー入力
    ↓
GDScriptゲームロジック
    ↓
C++ VoxelモジュールAPI
    ↓
ボクセルデータ変更
    ↓
メッシュ生成 (C++)
    ↓
レンダリング (Godotエンジン)
```

**重要な洞察:** パフォーマンス重視の操作はC++に留まり、ゲーム固有のロジックはGDScriptで柔軟性を保ちます。
